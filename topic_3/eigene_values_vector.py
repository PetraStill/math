"""
Чому np.linalg.eig(A) повертає "інші" власні вектори, ніж я задала вручну?

1) Власний вектор НЕ унікальний.
   Якщо v — власний вектор для λ (тобто A @ v = λ * v), то будь-який ненульовий множник
   c * v (де c ≠ 0) — теж власний вектор для того ж λ.
   Тому [1, -1], [-1, 1], [2, -2], [-0.707, 0.707] — це один і той самий напрямок.

2) np.linalg.eig зазвичай повертає власні вектори у "нормалізованому" вигляді:
   - довжина (норма) вектора ≈ 1
   - знак може відрізнятися (v і -v еквівалентні як власні вектори)

3) eigenvectors повертається як матриця, де КОЖЕН СТОВПЕЦЬ — окремий власний вектор,
   який відповідає eigenvalues з тим самим індексом.
   Тобто: A @ eigenvectors[:, i] ≈ eigenvalues[i] * eigenvectors[:, i]

Висновок: "інший" вигляд у виводі — це очікувано. Це той самий напрямок, лише з іншою
довжиною та/або знаком.
"""


import numpy as np

A = np.array([[3, 1], [0, 2]], dtype=float)

v1 = np.array([1, 0])
v2 = np.array([1, -1])

lambda1 = 3
lambda2 = 2

print("Перевірка першого власного вектора:")
print(f"A @ v₁ = {A @ v1}")
print(f"λ₁ * v₁ = {lambda1 * v1}")

print("\nПеревірка другого власного вектора:")
print(f"A @ v₂ = {A @ v2}")
print(f"λ₂ * v₂ = {lambda2 * v2}")

eigenvalues, eigenvectors = np.linalg.eig(A)

print("\nВласні вектори:")
print(eigenvectors)