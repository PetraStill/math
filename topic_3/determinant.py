import numpy as np  # Імпорт бібліотеки NumPy для роботи з масивами/матрицями та лінійною алгеброю

# Створюємо матрицю коефіцієнтів A (np.array) і задаємо тип float для коректних обчислень з дробами
A = np.array([
    [2, 1, -1],
    [1, 3, 2],
    [-1, 2, 1]
], dtype=float)

# np.linalg.det(A) — обчислює визначник (determinant) матриці A
det_A = np.linalg.det(A)
print(f"\nВизначник det(A) = {det_A:.4f}")

# abs(det_A) — модуль (абсолютне значення) числа det_A
# 1e-10 — дуже малий поріг (1 × 10^-10), щоб врахувати похибки обчислень з плаваючою комою
# Перевіряємо, чи визначник "не нульовий" (тобто матриця практично оборотна)
if abs(det_A) > 1e-10:
    print("Обернена матриця існує")
    
    # np.linalg.inv(A) — обчислює обернену матрицю A^{-1} (існує, якщо det(A) ≠ 0)
    A_inv = np.linalg.inv(A)
    print("\nОбернена матриця:")
    print(A_inv)
    
    # np.array([...]) — створює вектор вільних членів b
    b = np.array([8, 13, 5])
    
    # Оператор @ — матричне множення (matrix multiplication)
    # Тут обчислюємо розв’язок за формулою x = A^{-1} b
    x = A_inv @ b
    
    print(f"\nРозв'язок системи через обернену матрицю:")
    print(f"x = {x}")
    
    # np.linalg.solve(A, b) — розв’язує систему лінійних рівнянь Ax = b напряму (без явного обернення)
    x_solve = np.linalg.solve(A, b)
    print(f"\nРозв'язок через np.linalg.solve:")
    print(f"x = {x_solve}")
    
    # np.linalg.norm(v) — обчислює норму (довжину) вектора v; за замовчуванням це евклідова норма
    # Тут вимірюємо різницю між двома способами отримання розв’язку
    print(f"\nРізниця між методами: {np.linalg.norm(x - x_solve):.2e}")
else:
    # Якщо визначник занадто малий (близький до нуля), матриця необоротна або майже необоротна
    print("Обернена матриця не існує (det(A) ≈ 0). Система може не мати єдиного розв’язку.")
