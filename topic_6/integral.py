# ============================================================
# ПРИКЛАДИ ЧИСЕЛЬНОГО ІНТЕГРУВАННЯ У SciPy (quad)
# ============================================================
# quad = "QUADPACK" (набір алгоритмів чисельного інтегрування).
# Ідея: комп’ютер не «знає первісну», тому наближує площу під графіком
# (сума дуже тонких прямокутників/адаптивне розбиття інтервалу).
#
# Сигнатура (спрощено):
#   result, error = quad(func, a, b, args=(), ...)
# де:
#   func  - функція f(x), яку інтегруємо (те, що ми додаємо по шматочках)
#   a, b  - межі інтегрування (можна np.inf / -np.inf)
#   result - чисельне наближення інтеграла
#   error  - оцінка абсолютної похибки (наскільки метод може помилятися)
# ============================================================

import numpy as np
from scipy.integrate import quad


# ------------------------------------------------------------
# ПРИКЛАД 1. ∫₀² x² dx
# Навіщо: це «накопичення» величини x² на відрізку [0, 2],
# тобто площа під кривою y = x² між 0 та 2.
# Аналітично: ∫ x² dx = x³/3, тому ∫₀² x² dx = 8/3 ≈ 2.666666...
# ------------------------------------------------------------
def f_x2(x):
    return x**2

res1, err1 = quad(f_x2, 0, 2)

print("\n=== Приклад 1: ∫₀² x² dx ===")
print(f"Результат: {res1}")
print(f"Оцінка похибки: {err1:.2e}")


# ------------------------------------------------------------
# ПРИКЛАД 2. ∫₀² e^(−x²) dx (функція Гауса на [0,2])
# Навіщо: гаусівська крива часто з’являється у статистиці/фізиці.
# Для e^(−x²) немає елементарної первісної (вона виражається через erf),
# тому чисельне інтегрування — стандартний інструмент.
# ------------------------------------------------------------
def f_gauss(x):
    return np.exp(-x**2)

res2, err2 = quad(f_gauss, 0, 2)

print("\n=== Приклад 2: ∫₀² e^(−x²) dx ===")
print(f"Результат: {res2:.10f}")
print(f"Оцінка похибки: {err2:.2e}")


# ------------------------------------------------------------
# ПРИКЛАД 3. ∫₀^π sin(x) dx
# Навіщо: «площа» під синусом на [0, π].
# Аналітично відомо: ∫₀^π sin(x) dx = 2, але тут показуємо,
# як quad це відтворює чисельно.
# ------------------------------------------------------------
def f_sin(x):
    return np.sin(x)

res3, err3 = quad(f_sin, 0, np.pi)

print("\n=== Приклад 3: ∫₀^π sin(x) dx ===")
print(f"Результат: {res3}")
print(f"Оцінка похибки: {err3:.2e}")


# ------------------------------------------------------------
# ПРИКЛАД 4. ∫₀¹⁰ (sin(x)/x) dx — sinc
# Навіщо: для sin(x)/x немає елементарної первісної.
# Також є технічний момент: у x=0 формула sin(x)/x дає 0/0,
# але границя існує і дорівнює 1, тому робимо окрему обробку x=0.
# ------------------------------------------------------------
def sinc(x):
    # у точці 0 визначаємо значення через границю: lim_{x->0} sin(x)/x = 1
    if x == 0:
        return 1.0
    return np.sin(x) / x

res4, err4 = quad(sinc, 0, 10)

print("\n=== Приклад 4: ∫₀¹⁰ (sin(x)/x) dx (sinc) ===")
print(f"Результат: {res4:.10f}")
print(f"Оцінка похибки: {err4:.2e}")


# ------------------------------------------------------------
# ПРИКЛАД 5. Площа між кривими y=x та y=x² на [0,1]
# Навіщо: «площа між графіками» = ∫ |f(x) - g(x)| dx.
# На [0,1] маємо x ≥ x², тому модуль тут не критичний,
# але загальна формула з модулем універсальна.
# ------------------------------------------------------------
def f_line(x):
    return x

def f_parabola(x):
    return x**2

def area_between(x):
    return np.abs(f_line(x) - f_parabola(x))

a, b = 0, 1
res5, err5 = quad(area_between, a, b)

print("\n=== Приклад 5: площа між y=x та y=x² на [0,1] ===")
print(f"Результат: {res5}")
print(f"Оцінка похибки: {err5:.2e}")


# ------------------------------------------------------------
# ПРИКЛАД 6. Нескінченна верхня межа: ∫₀^∞ e^(−x) dx
# Навіщо: демонстрація інтегрування на нескінченному проміжку.
# Аналітично: ∫₀^∞ e^(−x) dx = 1.
# У quad нескінченність задається як np.inf.
# ------------------------------------------------------------
def f_exp_decay(x):
    return np.exp(-x)

res6, err6 = quad(f_exp_decay, 0, np.inf)

print("\n=== Приклад 6: ∫₀^∞ e^(−x) dx ===")
print(f"Результат: {res6}")
print(f"Оцінка похибки: {err6:.2e}")


# ------------------------------------------------------------
# ПРИКЛАД 7. ∫₁^∞ 1/x² dx
# Навіщо: приклад збіжного інтеграла на нескінченності.
# Аналітично: ∫₁^∞ 1/x² dx = 1.
# ------------------------------------------------------------
def f_inv_x2(x):
    return 1 / x**2

res7, err7 = quad(f_inv_x2, 1, np.inf)

print("\n=== Приклад 7: ∫₁^∞ 1/x² dx ===")
print(f"Результат: {res7}")
print(f"Оцінка похибки: {err7:.2e}")


# ------------------------------------------------------------
# ПРИКЛАД 8. ∫₁^∞ 1/x dx
# Навіщо: показати випадок, де інтеграл НЕ збігається (розбігається).
# Аналітично: ∫₁^∞ 1/x dx = ∞ (логарифм росте без меж).
#
# ВАЖЛИВО: quad може повернути якесь число та попередження/велику похибку,
# але математично інтеграл розбігається. Тому результату довіряти не можна
# як «значенню інтеграла», бо його не існує як скінченного числа.
# ------------------------------------------------------------
def f_inv_x(x):
    return 1 / x

res8, err8 = quad(f_inv_x, 1, np.inf)

print("\n=== Приклад 8: ∫₁^∞ 1/x dx (розбіжний) ===")
print(f"Результат (формально з quad): {res8}")
print(f"Оцінка похибки/попередження: {err8}")
print("Примітка: математично цей інтеграл розбігається (нескінченний).")
