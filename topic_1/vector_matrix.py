import numpy as np

# Матриця 2×3
A = np.array([[1, 2, 3],
              [4, 5, 6]])

# Вектор розмірності 3
x = np.array([1, 0, 2])

# Множення матриці на вектор
b = A @ x

print("Матриця A (2×3):")
print(A)
print(f"\nВектор x (3,):")
print(x)
print(f"\nРезультат A @ x (2,):")
print(b)


"""
У цьому прикладі кожен рядок матриці grades множиться на вектор ваг weights, 
що дає зважену суму оцінок для кожного студента. Це типова операція в лінійних моделях.
"""
# Dataset: 4 студенти, 3 предмети
grades = np.array([[85, 90, 95],   # студент 0
                   [75, 80, 85],   # студент 1
                   [95, 95, 100],  # студент 2
                   [60, 70, 75]])  # студент 3

# Ваги важливості предметів
weights = np.array([0.3, 0.3, 0.4])

print("Оцінки студентів:")
print(grades)
print(f"\nВаги предметів: {weights}")

# Обчислюємо зважений бал для кожного студента
final_scores = grades @ weights

print(f"\nФінальні бали:")
for i, score in enumerate(final_scores):
    print(f"  Студент {i}: {score:.2f}")


"""
Якщо, наприклад, у нас є датасет на 100 зразків і кожен зразок описується 5 ознаками, 
то ми можемо організувати ці дані як матрицю розміру 100×5, де кожен рядок — це один зразок. 
Далі, якщо в нас є модель з вагами (це вектор розміру 5), 
то замість того щоб множити кожен рядок окремо на ваги (це 100 окремих операцій), 
ми можемо виконати одну матричну операцію — помножити всю матрицю 
100×5 на вектор ваг розміру 5.
Результатом буде вектор розміру 100 — по одному передбаченню для кожного зразка.
"""

# 100 зразків, 5 ознак
X = np.random.randn(100, 5)

# Вектор ваг для 5 ознак
w = np.array([0.5, -0.3, 0.8, 0.2, -0.1])

# Обробка всіх 100 зразків одночасно
predictions = X @ w

print(f"Розмірність даних: {X.shape}")
print(f"Розмірність ваг: {w.shape}")
print(f"Розмірність результату: {predictions.shape}")
print(f"\nПерші 5 передбачень: {predictions[:5]}")
